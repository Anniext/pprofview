// Code generated by pprofview plugin. DO NOT EDIT.
// This file is automatically injected to enable pprof profiling.

package main

import (
	"log"
	"os"
	"os/signal"
	"path/filepath"
	"runtime"
	"runtime/pprof"
	"strconv"
	"syscall"
	"time"
)

var (
	pprofCleanupFunc func()
	pprofCpuFile     *os.File
	pprofOutputDir   string
)

func init() {
	log.Println("[pprofview] pprof 初始化开始...")
	
	outputDir := os.Getenv("PPROF_OUTPUT_DIR")
	if outputDir == "" {
		log.Println("[pprofview] 未设置 PPROF_OUTPUT_DIR 环境变量，跳过 pprof 采集")
		return
	}
	
	pprofOutputDir = outputDir
	log.Printf("[pprofview] pprof 输出目录: %s", outputDir)
	
	// 确保输出目录存在
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		log.Printf("[pprofview] 无法创建输出目录: %v", err)
		return
	}
	
	// 设置采样率
	if memRateStr := os.Getenv("PPROF_MEM_RATE"); memRateStr != "" {
		if memRate, err := strconv.Atoi(memRateStr); err == nil && memRate > 0 {
			runtime.MemProfileRate = memRate
			log.Printf("[pprofview] 内存采样率: %d", memRate)
		}
	}
	
	if blockRateStr := os.Getenv("PPROF_BLOCK_RATE"); blockRateStr != "" {
		if blockRate, err := strconv.Atoi(blockRateStr); err == nil && blockRate > 0 {
			runtime.SetBlockProfileRate(blockRate)
			log.Printf("[pprofview] 阻塞采样率: %d", blockRate)
		}
	}
	
	if mutexFractionStr := os.Getenv("PPROF_MUTEX_FRACTION"); mutexFractionStr != "" {
		if mutexFraction, err := strconv.Atoi(mutexFractionStr); err == nil && mutexFraction > 0 {
			runtime.SetMutexProfileFraction(mutexFraction)
			log.Printf("[pprofview] 互斥锁采样率: %d", mutexFraction)
		}
	}
	
	// CPU 分析
	if os.Getenv("PPROF_ENABLE_CPU") == "true" {
		cpuFilePath := filepath.Join(outputDir, "cpu.pprof")
		f, err := os.Create(cpuFilePath)
		if err != nil {
			log.Printf("[pprofview] 无法创建 CPU profile 文件: %v", err)
		} else {
			if err := pprof.StartCPUProfile(f); err != nil {
				log.Printf("[pprofview] 无法启动 CPU profiling: %v", err)
				f.Close()
			} else {
				pprofCpuFile = f
				log.Printf("[pprofview] CPU profiling 已启动: %s", cpuFilePath)
			}
		}
	}
	
	// 设置清理函数
	pprofCleanupFunc = func() {
		if pprofCpuFile != nil {
			pprof.StopCPUProfile()
			pprofCpuFile.Close()
			log.Printf("[pprofview] CPU profiling 已完成")
		}
		writePprofProfiles(pprofOutputDir)
	}
	
	// 捕获中断信号
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
	
	go func() {
		<-sigChan
		log.Println("[pprofview] 收到退出信号，正在保存 pprof 数据...")
		if pprofCleanupFunc != nil {
			pprofCleanupFunc()
		}
		os.Exit(0)
	}()
	
	// 获取 CPU 采样持续时间
	cpuDuration := 30
	if durationStr := os.Getenv("PPROF_CPU_DURATION"); durationStr != "" {
		if d, err := strconv.Atoi(durationStr); err == nil && d > 0 {
			cpuDuration = d
		}
	}
	
	log.Printf("[pprofview] CPU 采样持续时间: %d 秒", cpuDuration)
	
	// 启动一个 goroutine 在指定时间后自动保存
	// 同时监控程序是否提前退出
	go func() {
		ticker := time.NewTicker(1 * time.Second)
		defer ticker.Stop()
		
		elapsed := 0
		for range ticker.C {
			elapsed++
			if elapsed >= cpuDuration {
				log.Println("[pprofview] CPU 采样时间到，保存 pprof 数据...")
				if pprofCleanupFunc != nil {
					pprofCleanupFunc()
					pprofCleanupFunc = nil
				}
				return
			}
		}
	}()
	
	// 注册程序退出时的钩子
	// 监控主 goroutine 数量变化，检测程序是否即将退出
	go func() {
		time.Sleep(100 * time.Millisecond) // 等待程序启动
		checkCount := 0
		lastCount := runtime.NumGoroutine()
		
		ticker := time.NewTicker(200 * time.Millisecond)
		defer ticker.Stop()
		
		for range ticker.C {
			current := runtime.NumGoroutine()
			
			// 如果 goroutine 数量持续很低或持续减少，说明程序即将退出
			if current <= 2 || (current < lastCount && current <= 3) {
				checkCount++
				if checkCount >= 2 { // 连续 2 次检查确认
					log.Println("[pprofview] 检测到程序即将退出，立即保存 pprof 数据...")
					if pprofCleanupFunc != nil {
						pprofCleanupFunc()
						pprofCleanupFunc = nil
					}
					return
				}
			} else {
				checkCount = 0
			}
			lastCount = current
		}
	}()
}



// writePprofProfiles 写入其他类型的 profile
func writePprofProfiles(outputDir string) {
	// 堆内存分析
	if os.Getenv("PPROF_ENABLE_HEAP") == "true" {
		heapFile := filepath.Join(outputDir, "heap.pprof")
		f, err := os.Create(heapFile)
		if err == nil {
			runtime.GC()
			if err := pprof.WriteHeapProfile(f); err == nil {
				log.Printf("[pprofview] 堆内存 profiling 已完成: %s", heapFile)
			}
			f.Close()
		}
	}
	
	// 协程分析
	if os.Getenv("PPROF_ENABLE_GOROUTINE") == "true" {
		goroutineFile := filepath.Join(outputDir, "goroutine.pprof")
		f, err := os.Create(goroutineFile)
		if err == nil {
			if err := pprof.Lookup("goroutine").WriteTo(f, 0); err == nil {
				log.Printf("[pprofview] 协程 profiling 已完成: %s", goroutineFile)
			}
			f.Close()
		}
	}
	
	// 阻塞分析
	if os.Getenv("PPROF_ENABLE_BLOCK") == "true" {
		blockFile := filepath.Join(outputDir, "block.pprof")
		f, err := os.Create(blockFile)
		if err == nil {
			if err := pprof.Lookup("block").WriteTo(f, 0); err == nil {
				log.Printf("[pprofview] 阻塞 profiling 已完成: %s", blockFile)
			}
			f.Close()
		}
	}
	
	// 互斥锁分析
	if os.Getenv("PPROF_ENABLE_MUTEX") == "true" {
		mutexFile := filepath.Join(outputDir, "mutex.pprof")
		f, err := os.Create(mutexFile)
		if err == nil {
			if err := pprof.Lookup("mutex").WriteTo(f, 0); err == nil {
				log.Printf("[pprofview] 互斥锁 profiling 已完成: %s", mutexFile)
			}
			f.Close()
		}
	}
	
	// 内存分配分析
	if os.Getenv("PPROF_ENABLE_ALLOCS") == "true" {
		allocsFile := filepath.Join(outputDir, "allocs.pprof")
		f, err := os.Create(allocsFile)
		if err == nil {
			runtime.GC()
			if err := pprof.Lookup("allocs").WriteTo(f, 0); err == nil {
				log.Printf("[pprofview] 内存分配 profiling 已完成: %s", allocsFile)
			}
			f.Close()
		}
	}
}
